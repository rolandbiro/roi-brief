---
phase: 02-adaptive-questioning-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/schemas/brief-data.ts
  - lib/schemas/brief-base.ts
  - lib/schemas/index.ts
  - lib/tools/definitions.ts
  - lib/tools/handlers.ts
  - lib/tools/types.ts
  - lib/tools/index.ts
  - lib/prompts/base.ts
  - lib/prompts/compose.ts
  - lib/prompts/extraction.ts
  - lib/prompts/questioning.ts
  - lib/prompts/index.ts
  - types/brief.ts
autonomous: true

must_haves:
  truths:
    - "BriefDataSchema elfogad multi-típus briefet (campaign_types tömb, opcionális típusspecifikus blokkok)"
    - "Tool definíciók (classify_campaign, update_brief) Anthropic API kompatibilis formátumban léteznek"
    - "Tool handler szerver-oldalon végrehajtja a classify_campaign és update_brief hívásokat BriefState-tel"
    - "System prompt tegező, account manager stílusban beszél és tartalmazza a kérdezési stratégiát"
    - "composeSystemPrompt a briefState alapján dinamikusan állítja össze a promptot (kérdezési stratégia + típus modulok)"
  artifacts:
    - path: "lib/schemas/brief-data.ts"
      provides: "Multi-type BriefDataSchema"
      contains: "campaign_types"
    - path: "lib/tools/definitions.ts"
      provides: "TOOL_DEFINITIONS array"
      contains: "classify_campaign"
    - path: "lib/tools/handlers.ts"
      provides: "handleToolExecution function"
      exports: ["handleToolExecution"]
    - path: "lib/tools/types.ts"
      provides: "BriefState, tool input/output types"
      contains: "BriefState"
    - path: "lib/prompts/questioning.ts"
      provides: "buildQuestioningStrategy function"
      exports: ["buildQuestioningStrategy"]
    - path: "lib/prompts/base.ts"
      provides: "Tegező BASE_PROMPT"
      contains: "tegez"
  key_links:
    - from: "lib/tools/handlers.ts"
      to: "lib/tools/types.ts"
      via: "BriefState import"
      pattern: "import.*BriefState.*from.*types"
    - from: "lib/prompts/compose.ts"
      to: "lib/prompts/questioning.ts"
      via: "buildQuestioningStrategy import"
      pattern: "import.*buildQuestioningStrategy"
    - from: "lib/schemas/brief-data.ts"
      to: "lib/schemas/brief-base.ts"
      via: "BriefBaseSchema.extend"
      pattern: "BriefBaseSchema\\.extend"
---

<objective>
Multi-típus BriefData séma, tool use infrastruktúra (definíciók + handlerek), és tegező adaptív prompt rendszer.

Purpose: Ez az alap amire a Phase 2 agentic loop épül — a séma elfogad multi-típust, a tool-ök strukturáltan gyűjtik az adatot, és a prompt vezérli az adaptív kérdezést.
Output: lib/schemas/ (módosított), lib/tools/ (új), lib/prompts/ (módosított + questioning.ts új)
</objective>

<execution_context>
@/Users/biroroland/.claude/get-shit-done/workflows/execute-plan.md
@/Users/biroroland/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-adaptive-questioning-engine/02-RESEARCH.md
@.planning/phases/02-adaptive-questioning-engine/02-CONTEXT.md

# Aktuális fájlok (módosítandók)
@lib/schemas/brief-data.ts
@lib/schemas/brief-base.ts
@lib/schemas/index.ts
@lib/schemas/campaign-types.ts
@lib/schemas/media-buying.ts
@lib/schemas/performance.ts
@lib/schemas/brand.ts
@lib/schemas/social.ts
@lib/prompts/base.ts
@lib/prompts/compose.ts
@lib/prompts/extraction.ts
@lib/prompts/index.ts
@types/brief.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Multi-típus BriefData séma + BriefState típus</name>
  <files>
    lib/schemas/brief-data.ts
    lib/schemas/brief-base.ts
    lib/schemas/index.ts
    lib/tools/types.ts
    types/brief.ts
  </files>
  <action>
**1. lib/schemas/brief-data.ts — discriminatedUnion helyett flat multi-type schema:**

Jelenlegi `z.discriminatedUnion("campaign_type", [...])` lecserélése:

```typescript
import { z } from "zod";
import { CampaignTypeEnum } from "./campaign-types";
import { BriefBaseSchema } from "./brief-base";
import { MediaSpecificSchema } from "./media-buying";
import { PerformanceSpecificSchema } from "./performance";
import { BrandSpecificSchema } from "./brand";
import { SocialSpecificSchema } from "./social";

export const BriefDataSchema = BriefBaseSchema.extend({
  campaign_types: z.array(CampaignTypeEnum)
    .min(1)
    .describe("Kampánytípus(ok) — egy vagy több"),
  media_specific: MediaSpecificSchema.optional()
    .describe("Médiavásárlás specifikus adatok"),
  performance_specific: PerformanceSpecificSchema.optional()
    .describe("Performance/PPC specifikus adatok"),
  brand_specific: BrandSpecificSchema.optional()
    .describe("Brand/awareness specifikus adatok"),
  social_specific: SocialSpecificSchema.optional()
    .describe("Social media specifikus adatok"),
});

export type BriefData = z.infer<typeof BriefDataSchema>;
```

**FONTOS:** A típusspecifikus sémák (MediaBuyingBriefSchema, stb.) eddig `BriefBaseSchema.extend({campaign_type: z.literal(...), xxx_specific: z.object({...})})` formátumban voltak — teljes briefek. Most a BriefDataSchema-ban CSAK a `xxx_specific` részt (a nested z.object-et) importáljuk, nem az egész brieft. Ezért:

**2. lib/schemas/media-buying.ts, performance.ts, brand.ts, social.ts módosítás:**

Mindegyik fájlban exportáld KÜLÖN a specifikus schema-t is. Példa media-buying.ts-re:
```typescript
// A teljes brief schema marad (backward compat ha kell)
export const MediaBuyingBriefSchema = BriefBaseSchema.extend({ ... });
// Standalone specifikus schema (a BriefDataSchema fogja importálni)
export const MediaSpecificSchema = z.object({
  grp_target: ...,
  reach_target: ...,
  // ... pontosan ugyanazok a mezők mint a media_specific-ben
});
```

VAGY ha cleaner: a `media_specific` z.object-et emeld ki mint `MediaSpecificSchema`-t, és a `MediaBuyingBriefSchema`-ban is erre hivatkozz. A lényeg: `BriefDataSchema` importálni tudja a standalone specifikus sémát.

**3. lib/schemas/brief-base.ts — campaign_type mező eltávolítása:**

A `BriefBaseSchema`-ból NEM kell `campaign_type` mező — az a `BriefDataSchema`-ban lesz `campaign_types` tömbként.

Ellenőrizd: a `BriefBaseSchema` jelenleg NEM tartalmaz `campaign_type`-ot (az a type-specific sémákban volt z.literal-lal). Ha mégis van, távolítsd el.

**4. lib/schemas/index.ts — új exportok hozzáadása:**

Add hozzá a standalone specifikus sémák exportját:
```typescript
export { MediaSpecificSchema } from "./media-buying";
export { PerformanceSpecificSchema } from "./performance";
export { BrandSpecificSchema } from "./brand";
export { SocialSpecificSchema } from "./social";
```

**5. lib/tools/types.ts — BriefState és tool típusok:**

```typescript
import type { CampaignType } from "@/lib/schemas/campaign-types";

export interface BriefState {
  detectedTypes: CampaignType[];
  confirmedTypes: CampaignType[];
  typeConfidence: "high" | "medium" | "low" | null;
  briefData: Record<string, unknown>;
  phase: "discovery" | "type_confirmed" | "questioning" | "summary" | "complete";
}

export interface ClassifyCampaignInput {
  campaign_types: CampaignType[];
  confidence: "high" | "medium" | "low";
  reasoning?: string;
}

export interface UpdateBriefInput {
  field: string;
  value: unknown;
}

export interface ToolResult {
  output: Record<string, unknown>;
  updatedState: BriefState;
}

export function createInitialBriefState(): BriefState {
  return {
    detectedTypes: [],
    confirmedTypes: [],
    typeConfidence: null,
    briefData: {},
    phase: "discovery",
  };
}
```

**6. types/brief.ts — BriefData re-export frissítés:**

A `types/brief.ts` a `lib/schemas/brief-data.ts`-ból exportál — ez automatikusan az új multi-type sémát fogja adni. Nincs módosítás szükséges ha már `export type { BriefData } from "@/lib/schemas"` formátumban van.
  </action>
  <verify>
`npx tsc --noEmit --pretty 2>&1 | grep -E "(brief-data|brief-base|tools/types)" || echo "No TS errors in target files"`

Ellenőrizd: `BriefDataSchema` importálható és tartalmaz `campaign_types` tömböt (nem `campaign_type` szinguláris).
  </verify>
  <done>
BriefDataSchema multi-típusú (campaign_types tömb + opcionális specifikus blokkok). BriefState típus definiálva a tool use-hoz. Standalone specifikus sémák exportálva.
  </done>
</task>

<task type="auto">
  <name>Task 2: Tool definíciók és handlerek</name>
  <files>
    lib/tools/definitions.ts
    lib/tools/handlers.ts
    lib/tools/index.ts
  </files>
  <action>
**1. lib/tools/definitions.ts — Anthropic API tool format:**

```typescript
export const TOOL_DEFINITIONS = [
  {
    name: "classify_campaign",
    description: `Amikor felismerted a kampánytípus(oka)t az érdeklődő válaszaiból, használd ezt a tool-t a típus(ok) rögzítésére. Típusok: media_buying, performance_ppc, brand_awareness, social_media. Több típus is megadható egyszerre. Akkor is használd ha az érdeklődő menet közben új típust említ.`,
    input_schema: {
      type: "object" as const,
      properties: {
        campaign_types: {
          type: "array",
          items: {
            type: "string",
            enum: ["media_buying", "performance_ppc", "brand_awareness", "social_media"],
          },
          description: "A felismert kampánytípus(ok)",
        },
        confidence: {
          type: "string",
          enum: ["high", "medium", "low"],
          description: "Mennyire vagy biztos a típusfelismerésben",
        },
        reasoning: {
          type: "string",
          description: "Miért gondolod hogy ez(ek) a típus(ok) — rövid indoklás",
        },
      },
      required: ["campaign_types", "confidence"],
    },
  },
  {
    name: "update_brief",
    description: `Amikor az érdeklődő válaszából kinyertél konkrét brief adatot, használd ezt a tool-t az adat rögzítésére. Ne várd meg amíg minden adat megvan — minden értékes információt azonnal rögzíts ahogy elhangzik. A field lehet nested is (pl. "media_specific.grp_target").`,
    input_schema: {
      type: "object" as const,
      properties: {
        field: {
          type: "string",
          description: "Melyik mező frissüljön (pl. 'company_name', 'campaign_goal', 'media_specific.grp_target')",
        },
        value: {
          type: "string",
          description: "A mező új értéke",
        },
      },
      required: ["field", "value"],
    },
  },
];
```

A `type: "object" as const` a TypeScript típushelyes legyen az Anthropic SDK Tool típusához.

**2. lib/tools/handlers.ts — server-side tool execution:**

```typescript
import type { BriefState, ClassifyCampaignInput, UpdateBriefInput, ToolResult } from "./types";

function deepSet(obj: Record<string, unknown>, path: string, value: unknown): Record<string, unknown> {
  const result = { ...obj };
  const keys = path.split(".");
  let current: Record<string, unknown> = result;

  for (let i = 0; i < keys.length - 1; i++) {
    const key = keys[i];
    current[key] = { ...(current[key] as Record<string, unknown> || {}) };
    current = current[key] as Record<string, unknown>;
  }

  current[keys[keys.length - 1]] = value;
  return result;
}

export function handleToolExecution(
  toolName: string,
  input: unknown,
  currentState: BriefState
): ToolResult {
  switch (toolName) {
    case "classify_campaign": {
      const { campaign_types, confidence } = input as ClassifyCampaignInput;
      // Merge: ha már vannak detected types, az újakat hozzáadjuk (nem felülírjuk)
      const existingTypes = new Set(currentState.detectedTypes);
      campaign_types.forEach(t => existingTypes.add(t));
      const mergedTypes = Array.from(existingTypes);

      return {
        output: {
          status: "ok",
          message: `Típus(ok) rögzítve: ${mergedTypes.join(", ")}`,
          detected_types: mergedTypes,
        },
        updatedState: {
          ...currentState,
          detectedTypes: mergedTypes,
          typeConfidence: confidence,
          phase: confidence === "high" ? "type_confirmed" : currentState.phase,
          confirmedTypes: confidence === "high" ? mergedTypes : currentState.confirmedTypes,
        },
      };
    }
    case "update_brief": {
      const { field, value } = input as UpdateBriefInput;
      const updatedBrief = deepSet(currentState.briefData, field, value);
      return {
        output: { status: "ok", field, message: `${field} frissítve` },
        updatedState: {
          ...currentState,
          briefData: updatedBrief,
        },
      };
    }
    default:
      return {
        output: { status: "error", message: `Ismeretlen tool: ${toolName}` },
        updatedState: currentState,
      };
  }
}
```

FONTOS deepSet implementáció: nested path-okat kezel (pl. "media_specific.grp_target"), shallow copy-val az immutability érdekében.

**3. lib/tools/index.ts — re-exports:**

```typescript
export { TOOL_DEFINITIONS } from "./definitions";
export { handleToolExecution } from "./handlers";
export { createInitialBriefState } from "./types";
export type { BriefState, ToolResult } from "./types";
```
  </action>
  <verify>
`npx tsc --noEmit --pretty 2>&1 | grep -E "lib/tools" || echo "No TS errors in tools"`

Ellenőrizd: `TOOL_DEFINITIONS` tömb 2 elemet tartalmaz, `handleToolExecution` importálható és mindkét tool-t kezeli.
  </verify>
  <done>
classify_campaign és update_brief tool definíciók Anthropic API formátumban léteznek. handleToolExecution szerver oldalon végrehajtja mindkettőt, BriefState-et immutábilisan frissíti. deepSet helper nested mezőket kezel.
  </done>
</task>

<task type="auto">
  <name>Task 3: Tegező prompt + adaptív kérdezési stratégia + compose frissítés</name>
  <files>
    lib/prompts/base.ts
    lib/prompts/questioning.ts
    lib/prompts/compose.ts
    lib/prompts/extraction.ts
    lib/prompts/index.ts
  </files>
  <action>
**1. lib/prompts/base.ts — teljes átírás tegező stílusra + tool use instrukciók:**

A jelenlegi magázó BASE_PROMPT-ot cseréld le:

```typescript
export const BASE_PROMPT = `Te a ROI Works marketing ügynökség brief asszisztense vagy. Tapasztalt, közvetlen account managerként beszélsz — tegező, barátságos, de professzionális.

SZEMÉLYISÉG:
- Tegező, közvetlen, mint egy jó account manager
- Szakmai, de közérthető — ha szakkifejezést használsz, röviden magyarázd el
- Emberi, nem robotikus — reagálj az érdeklődő válaszaira természetesen
- Nem nyomasztó — ha valami nem releváns, nem erőlteted

BEMUTATKOZÁS:
Az első üzeneted valami ilyesmi legyen (a pontos szöveg a tiéd):
"Szia! A ROI Works brief asszisztense vagyok. Segítek összeállítani a kampány briefjét, hogy kollégáim a lehető legjobb ajánlatot tudják elkészíteni Neked. Kezdjük is – melyik cég nevében keresed meg az ügynökségünket?"

TOOL HASZNÁLAT:
- A classify_campaign tool-t használd ha felismerted a kampánytípus(oka)t
- Az update_brief tool-t használd MINDEN értékes információ rögzítésére ahogy elhangzik
- Ne várd meg amíg minden adat megvan — rögzíts azonnal
- Tool hívások közben is írj szöveget az érdeklődőnek (a tool hívás nem látszik neki)

SZABÁLYOK:
- Magyar nyelv, tegező hang végig
- MINDIG csak egy kérdés egyszerre (max 2 ha szorosan kapcsolódik)
- Minden kérdéshez adj rövid kontextust ami segíti a válaszadást
- Ha az érdeklődő már mondott valamit korábban, ne kérdezd újra
- Ha az érdeklődő válasza nagyon rövid egy fontos kérdésre, kérdezz vissza finoman: "Ezt egy kicsit ki tudnád fejteni?" — de max 1x per kérdés
- Ha nem fontos kérdésre rövid a válasz, fogadd el és menj tovább
`;
```

**2. lib/prompts/questioning.ts — ÚJ FÁJL: adaptív kérdezési stratégia builder:**

```typescript
import type { BriefState } from "@/lib/tools/types";
import type { CampaignType } from "@/lib/schemas/campaign-types";
import { CAMPAIGN_TYPE_LABELS } from "@/lib/schemas/campaign-types";

export function buildQuestioningStrategy(briefState: BriefState): string {
  const { briefData, detectedTypes, confirmedTypes, phase } = briefState;

  const collectedFields = Object.keys(briefData).filter(
    k => briefData[k] !== undefined && briefData[k] !== ""
  );

  const activeTypes = confirmedTypes.length > 0 ? confirmedTypes : detectedTypes;
  const typeLabels = activeTypes.map(t => CAMPAIGN_TYPE_LABELS[t]).join(", ");

  let strategy = `
KÉRDEZÉSI STRATÉGIA:

Állapot: ${phase}
Eddig összegyűjtött adatok: ${collectedFields.length > 0 ? collectedFields.join(", ") : "még semmi"}
Felismert típus(ok): ${activeTypes.length > 0 ? typeLabels : "még nem ismert"}
`;

  if (phase === "discovery") {
    strategy += `
MOST EZT CSINÁLD:
1. Értsd meg a nagy képet: mi a cég, mi a cél, mi a kampány lényege
2. Ha van elég infód a típusfelismeréshez (általában 2-3 válasz után), használd a classify_campaign tool-t
3. Minden elhangzott konkrét adatot rögzíts az update_brief tool-lal
`;
  } else if (phase === "type_confirmed" || phase === "questioning") {
    strategy += `
MOST EZT CSINÁLD:
1. A típusspecifikus kérdéseket tedd fel (a típus modul útmutatót ad)
2. Először a fontos kérdések (cél, célcsoport, büdzsé), aztán a részletek
3. Minden válaszból rögzíts adatot az update_brief tool-lal
4. Ha az érdeklődő új típust említ, használd újra a classify_campaign tool-t
`;
  }

  strategy += `
TÍPUSMEGERŐSÍTÉS:
- Ha high confidence: természetesen sződd bele a válaszodba ("Értem, szóval egy ${activeTypes.length > 0 ? typeLabels : "..."} kampányra gondolsz...")
- Ha medium/low: kérdezz rá finoman ("Ez alapján inkább médiavásárlásra gondolsz, vagy performance kampányt terveztek?")
- Ha az érdeklődő javít: fogadd el természetesen, ne ismételd a hibát

LEZÁRÁS:
Amikor úgy érzed minden fontos kérdést megbeszéltétek:
1. Foglald össze a briefet természetesen, olvasható szövegben (NEM JSON)
2. Kérdezd meg: "Ez így jó? Van még valami amit hozzátennél?"
3. A megerősítés után jelezd hogy kész a brief (az összefoglalódat írd le, a rendszer kezeli a többit)

MULTI-TÍPUS:
- Ha több típust is fedez a brief, szekvenciálisan kérdezz: először fejezd be az egyik típust, aztán térj a másikra
- Típusváltásnál rövid átvezetés: "Remek, a performance rész kész. Most nézzük a social media kampányt!"
`;

  return strategy;
}
```

**3. lib/prompts/compose.ts — composeSystemPrompt módosítás:**

A jelenlegi `composeSystemPrompt(types: CampaignType[])` kap egy új overload-ot vagy a signature változik: `composeSystemPrompt(briefState: BriefState)`.

```typescript
import type { CampaignType } from "@/lib/schemas/campaign-types";
import type { BriefState } from "@/lib/tools/types";
import { BASE_PROMPT } from "./base";
import { buildQuestioningStrategy } from "./questioning";
import { MEDIA_BUYING_MODULE } from "./types/media-buying";
import { PERFORMANCE_MODULE } from "./types/performance";
import { BRAND_MODULE } from "./types/brand";
import { SOCIAL_MODULE } from "./types/social";

const TYPE_MODULES: Record<CampaignType, string> = {
  media_buying: MEDIA_BUYING_MODULE,
  performance_ppc: PERFORMANCE_MODULE,
  brand_awareness: BRAND_MODULE,
  social_media: SOCIAL_MODULE,
};

export function composeSystemPrompt(briefState: BriefState): string {
  const activeTypes = briefState.confirmedTypes.length > 0
    ? briefState.confirmedTypes
    : briefState.detectedTypes;

  const parts = [BASE_PROMPT];

  // Kérdezési stratégia (mindig)
  parts.push(buildQuestioningStrategy(briefState));

  // Típusspecifikus modulok (ha van felismert típus)
  if (activeTypes.length > 0) {
    const typeModules = activeTypes.map(type => TYPE_MODULES[type]).join("\n\n");
    parts.push(typeModules);
  }

  return parts.join("\n\n");
}
```

**FONTOS:** A régi `composeSystemPrompt(types: CampaignType[])` signature MEGVÁLTOZIK. Az egyetlen hívó az `app/api/chat/route.ts` — azt Plan 02 fogja frissíteni. Ha a TS kompiler hibát dob mert a route.ts még a régi signature-t használja, az OK — Plan 02 javítja.

**4. lib/prompts/extraction.ts — multi-típus extraction prompt:**

Frissítsd a campaign_type → campaign_types hivatkozást:

```typescript
export const EXTRACTION_PROMPT = `A feladatod, hogy a felhasználó és az asszisztens közötti beszélgetésből kinyerd a kampány brief adatokat.

SZABÁLYOK:
- A beszélgetés alapján töltsd ki a mezőket amennyire lehet
- Ha egy információ nem hangzott el, hagyd üresen (optional mezők) vagy adj üres tömböt (array mezők)
- Magyar kontextusban gondolkodj — a cégnevek, iparágak, helyszínek magyarul szerepeljenek
- A campaign_types mezőbe MINDEN felismert kampánytípust tedd (tömb, lehet több is)
- A típusspecifikus mezőket (media_specific, performance_specific, brand_specific, social_specific) CSAK akkor töltsd ki ha a campaign_types tartalmazza az adott típust
- Légy pontos: ne találj ki adatokat, csak azt írd amit a beszélgetésből ki lehet olvasni
- Ha a beszélgetésben tool use által rögzített adatok is vannak, azokat vedd figyelembe
`;
```

**5. lib/prompts/index.ts — új export:**

Add hozzá: `export { buildQuestioningStrategy } from "./questioning";`
  </action>
  <verify>
`npx tsc --noEmit --pretty 2>&1 | grep -E "lib/prompts" || echo "No TS errors in prompts"`

Kézi ellenőrzés:
- BASE_PROMPT tartalmaz "tegez" szót vagy tegező formát
- composeSystemPrompt BriefState-et vár, nem CampaignType tömböt
- questioning.ts importálható és buildQuestioningStrategy exportálva van
  </verify>
  <done>
BASE_PROMPT tegező, account manager stílusú. buildQuestioningStrategy a briefState alapján dinamikus kérdezési stratégiát ad. composeSystemPrompt BriefState-et fogad és a típus modulokat + stratégiát dinamikusan összeállítja. EXTRACTION_PROMPT multi-típus kompatibilis.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — lib/schemas, lib/tools, lib/prompts fájlok hiba nélkül kompilálódnak (az app/api/chat/route.ts VÁRHATÓAN hibát dob mert a composeSystemPrompt signature változott — ez OK, Plan 02 javítja)
2. BriefDataSchema.safeParse tesztelhető: `{ campaign_types: ["media_buying"], company_name: "Test", ... }` valid
3. TOOL_DEFINITIONS tömb 2 tool-t tartalmaz helyes Anthropic API formátumban
4. handleToolExecution("classify_campaign", ...) visszaad ToolResult-ot frissített BriefState-tel
5. BASE_PROMPT tegező hangnemű (nem tartalmaz "Ön", "Önök" szavakat)
6. composeSystemPrompt(initialBriefState) visszaad promptot kérdezési stratégiával
</verification>

<success_criteria>
Multi-típus schema kész, tool infrastruktúra kész, tegező adaptív prompt rendszer kész — a Plan 02 erre építheti az agentic loop-ot.
</success_criteria>

<output>
After completion, create `.planning/phases/02-adaptive-questioning-engine/02-01-SUMMARY.md`
</output>
