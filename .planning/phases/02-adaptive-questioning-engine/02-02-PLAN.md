---
phase: 02-adaptive-questioning-engine
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - app/api/chat/route.ts
  - hooks/useChat.ts
  - types/chat.ts
autonomous: true

must_haves:
  truths:
    - "Chat API route agentic loop-ot futtat: streaming Claude hívás → tool_use detektálás → szerver-oldali tool execution → tool_result visszaküldés → folytatás, amíg end_turn"
    - "Tool_use és tool_result blokkok NEM jelennek meg a kliens SSE streamben — csak text, briefState, quickReplies és [DONE]"
    - "useChat hook tárolja és visszaküldi a briefState-et minden request-ben"
    - "Max 10 iteráció az agentic loop-ban (infinite loop védelem)"
    - "SSE stream briefState és quickReplies metadata-t küld a text mellett"
  artifacts:
    - path: "app/api/chat/route.ts"
      provides: "Agentic loop with tool use within SSE stream"
      contains: "handleToolExecution"
    - path: "hooks/useChat.ts"
      provides: "briefState management, quickReplies state"
      contains: "briefState"
    - path: "types/chat.ts"
      provides: "QuickReply type, Message extension"
      contains: "QuickReply"
  key_links:
    - from: "app/api/chat/route.ts"
      to: "lib/tools/handlers.ts"
      via: "handleToolExecution import"
      pattern: "import.*handleToolExecution.*from.*tools"
    - from: "app/api/chat/route.ts"
      to: "lib/prompts/compose.ts"
      via: "composeSystemPrompt(briefState)"
      pattern: "composeSystemPrompt\\(.*briefState"
    - from: "hooks/useChat.ts"
      to: "app/api/chat/route.ts"
      via: "fetch with briefState in body"
      pattern: "briefState"
---

<objective>
Chat API route átírás agentic loop-pal (tool use + SSE) és useChat hook frissítés briefState managementtel.

Purpose: Ez a fázis fő motorja — az AI tool use-szal felismeri a típust és gyűjti az adatot, a kliens pedig kezeli a briefState-et és quick-reply opciókat.
Output: app/api/chat/route.ts (átírva), hooks/useChat.ts (frissítve), types/chat.ts (bővítve)
</objective>

<execution_context>
@/Users/biroroland/.claude/get-shit-done/workflows/execute-plan.md
@/Users/biroroland/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-adaptive-questioning-engine/02-RESEARCH.md
@.planning/phases/02-adaptive-questioning-engine/02-CONTEXT.md
@.planning/phases/02-adaptive-questioning-engine/02-01-SUMMARY.md

# Aktuális fájlok (módosítandók)
@app/api/chat/route.ts
@hooks/useChat.ts
@types/chat.ts

# Függőségek (Plan 01 kimenetei)
@lib/tools/index.ts
@lib/tools/definitions.ts
@lib/tools/handlers.ts
@lib/tools/types.ts
@lib/prompts/compose.ts
@lib/prompts/questioning.ts
@lib/prompts/extraction.ts
@lib/schemas/brief-data.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Chat API route átírás agentic loop-pal</name>
  <files>
    app/api/chat/route.ts
  </files>
  <action>
Az `app/api/chat/route.ts` teljes átírása. A jelenlegi egyszerű streaming + opcionális extraction hívást az agentic loop váltja fel.

**Követelmények:**

1. **Request body:** `{ messages, briefState, extractBrief }` — a briefState a kliens küldi vissza minden turn-ben.

2. **Agentic loop logika:**
   - A Claude hívás `tools: TOOL_DEFINITIONS`-t kap
   - `stream: true` — streaming válasz
   - A szerver for-await loop-ban dolgozza fel az event-eket:
     - `content_block_delta` + `text_delta` → SSE-re küldés (`{text: ...}`)
     - `content_block_start` + `tool_use` → tool accumulator indítás (NEM SSE-re)
     - `content_block_delta` + `input_json_delta` → tool input JSON akkumulálás (NEM SSE-re)
     - `content_block_stop` ha tool → tool block befejezés, JSON parse
     - `message_delta` → stop_reason elmentés
   - Ha `stop_reason === "tool_use"`:
     - Építs assistant message-et (text + tool_use blokkok)
     - Hajtsd végre a tool-okat `handleToolExecution`-nal
     - Küldj `{briefState: currentBriefState}` SSE event-et a kliensnek
     - Építs tool_result user message-et
     - Folytasd a loop-ot (újabb Claude hívás a bővített messages-szel)
   - Ha `stop_reason === "end_turn"`:
     - Loop vége
   - **MAX_ITERATIONS = 10** — ha eléri, kényszerített leállás

3. **Quick-reply metadata:** A stream végén (de `[DONE]` előtt) ha a `briefState.phase` "questioning" és a legutolsó text tartalmaz kérdést, NEM küldünk quick-reply-t most — azt a prompt vezérli, és a Plan 03 UI-ja fogja kezelni. VISZONT az SSE formátum támogassa: `{quickReplies: [...]}`.

4. **Extraction hívás:** Ha `extractBrief: true`, az agentic loop UTÁN (nem helyette) hívd meg a `messages.parse()` + `zodOutputFormat(BriefDataSchema)` hívást — pontosan mint a jelenlegi rendszerben, de az EXTRACTION_PROMPT is megkapja a `currentBriefState` tartalmát context-ként, hogy ne veszítsen el tool use-szal gyűjtött adatot.

5. **System prompt:** `composeSystemPrompt(currentBriefState)` — a BriefState-et kapja, nem CampaignType tömböt.

6. **Error handling:** A meglévő try-catch struktúra marad, de bővítsd a loop iteráció túllépés kezelésével (ha MAX_ITERATIONS elérve, küldj warning-ot SSE-n és zárd le).

**Referencia implementáció a RESEARCH.md Pattern 1-ben** — azt kövesd, de adaptáld a fenti követelményekhez.

FONTOS anti-pattern: A `tool_use` content block deltaját (input_json_delta) NE küldd SSE-re. A kliens SOHA nem láthatja a tool JSON-t. Csak `text_delta` megy ki.
  </action>
  <verify>
`npx tsc --noEmit --pretty 2>&1 | grep "route.ts" || echo "No TS errors in route.ts"`

Kézi review:
- A route.ts importálja a `TOOL_DEFINITIONS`-t és `handleToolExecution`-t
- Van `while (continueLoop)` vagy hasonló loop
- Van `MAX_ITERATIONS` konstans
- Az SSE-n NEM jelenik meg `tool_use` vagy `input_json_delta`
- A `composeSystemPrompt` BriefState-et kap
  </verify>
  <done>
Chat API route agentic loop-pal működik: streaming text → tool detection → server-side execution → continuation. Tool blokkok nem jutnak a kliensre. Max 10 iteráció. briefState frissítés SSE-n át.
  </done>
</task>

<task type="auto">
  <name>Task 2: useChat hook + types frissítés (briefState management, quickReplies)</name>
  <files>
    hooks/useChat.ts
    types/chat.ts
  </files>
  <action>
**1. types/chat.ts — QuickReply típus és Message bővítés:**

```typescript
export interface Message {
  id: string;
  role: "user" | "assistant";
  content: string;
  timestamp: Date;
}

export interface QuickReply {
  label: string;
  value: string | null; // null = szabad szöveg (fókusz az input mezőre)
}

// Re-export BriefData from new canonical location for backward compatibility
export type { BriefData } from "@/types/brief";
```

**2. hooks/useChat.ts — briefState management + quickReplies:**

A hook bővül:
- `briefState` useState — `BriefState` típussal (import from `@/lib/tools/types`), `createInitialBriefState()` kezdőértékkel
- `quickReplies` useState — `QuickReply[] | null`
- `processStream` bővül: `briefState` és `quickReplies` SSE event-ek kezelése
- `sendMessage` és `startChat` a body-ban küldi a `briefState`-et
- `handleQuickReply` callback: quick-reply kattintáskor quickReplies null-ra és sendMessage hívás (ha value nem null) vagy fókusz inputra (ha null)

**Részletes módosítások:**

a) **Új state-ek és importok:**
```typescript
import { BriefState, createInitialBriefState } from "@/lib/tools";
import { QuickReply } from "@/types/chat";

// A hook-ban:
const [briefState, setBriefState] = useState<BriefState>(createInitialBriefState());
const [quickReplies, setQuickReplies] = useState<QuickReply[] | null>(null);
```

b) **processStream bővítés:**
A meglévő SSE parser loop-ban kezelendő új event-ek:
```typescript
if (parsed.briefState) {
  setBriefState(parsed.briefState);
  currentBriefState = parsed.briefState; // lokális változó a request body-hoz
}
if (parsed.quickReplies) {
  setQuickReplies(parsed.quickReplies);
}
```

A `processStream` visszatérési értéke bővül: `{ content, briefData, briefState }`.

c) **sendMessage body bővítés:**
```typescript
body: JSON.stringify({
  messages: allMessages,
  briefState: briefState,  // <-- ÚJ
}),
```

d) **startChat body bővítés:**
```typescript
body: JSON.stringify({
  messages: [{ role: "user", content: "Szia!" }],
  briefState: briefState,  // <-- ÚJ (initial state)
}),
```

e) **handleQuickReply callback:**
```typescript
const handleQuickReply = useCallback((value: string | null) => {
  setQuickReplies(null); // Gombok eltűnnek
  if (value !== null) {
    sendMessage(value);
  }
  // Ha null (= "Egyéb"), a ChatContainer fogja kezelni az input fókuszálást
}, [sendMessage]);
```

f) **Minden sendMessage hívás előtt töröld a quick-reply-okat:**
A `sendMessage` elején: `setQuickReplies(null);`

g) **Return bővítés:**
A hook return-jébe add hozzá: `briefState`, `quickReplies`, `handleQuickReply`

h) **Extraction — requestExtraction body bővítés:**
Az extractBrief hívásba is add bele a briefState-et:
```typescript
body: JSON.stringify({
  messages: allMessages,
  extractBrief: true,
  briefState: briefState,
}),
```

FONTOS: A `messages` state stabil marad (role: "user" | "assistant", content: string). A tool_use/tool_result blokkok a szerveren maradnak, a kliens SOHA nem kapja meg őket a messages-ben. A `briefState` a szerveren frissül (tool execution) és SSE-n jön vissza a kliensre.
  </action>
  <verify>
`npx tsc --noEmit --pretty 2>&1 | grep -E "(useChat|chat\\.ts)" || echo "No TS errors"`

Kézi review:
- useChat hook return-jében van `briefState`, `quickReplies`, `handleQuickReply`
- sendMessage body tartalmaz `briefState`-et
- processStream kezeli a `briefState` és `quickReplies` SSE event-eket
- QuickReply interface exportálva a types/chat.ts-ből
  </verify>
  <done>
useChat hook briefState-et kezel (tárolja, visszaküldi, frissíti SSE-ből). QuickReply típus definiálva. handleQuickReply callback elérhető. A hook API bővült de a meglévő fogyasztók (brief/page.tsx) visszafelé kompatibilisek.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — app/api/chat/route.ts, hooks/useChat.ts, types/chat.ts hiba nélkül kompilálódik
2. Chat API route tartalmaz agentic loop-ot (while loop, stop_reason check, tool execution)
3. Tool blokkok NEM jelennek meg SSE stream-ben (grep: nem tartalmaz "input_json_delta" az SSE encode-ban)
4. useChat hook briefState-et küld a request body-ban
5. QuickReply interface létezik types/chat.ts-ben
6. A dev szerver elindul: `npm run dev` (ha nem, a TS error-ok miatt Plan 01 hiányozhat)
</verification>

<success_criteria>
A teljes agentic loop működik: kliens küld üzenetet → szerver streaming válasz → tool use detection → server-side tool execution → continuation → kliens briefState update. Ez a Phase 2 motorja.
</success_criteria>

<output>
After completion, create `.planning/phases/02-adaptive-questioning-engine/02-02-SUMMARY.md`
</output>
