---
phase: 02-adaptive-questioning-engine
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - components/chat/QuickReplies.tsx
  - components/chat/ChatContainer.tsx
  - components/chat/ChatInput.tsx
  - app/brief/page.tsx
autonomous: false

must_haves:
  truths:
    - "Quick-reply gombok megjelennek a chat-ben amikor a szerver quickReplies-t küld"
    - "Quick-reply gomb kattintáskor a szöveg elküldődik mint user üzenet és a gombok eltűnnek"
    - "Szabad szöveg beírás esetén is eltűnnek a quick-reply gombok"
    - "A teljes adaptív kérdezés flow működik: bemutatkozás → típusfelismerés → típusmegerősítés → adaptív kérdések → összefoglaló"
    - "Tegező hangnem végig, account manager feeling"
  artifacts:
    - path: "components/chat/QuickReplies.tsx"
      provides: "Quick-reply button component"
      contains: "QuickReplies"
    - path: "components/chat/ChatContainer.tsx"
      provides: "Quick-reply rendering in chat"
      contains: "QuickReplies"
    - path: "app/brief/page.tsx"
      provides: "briefState és quickReplies integration"
      contains: "quickReplies"
  key_links:
    - from: "components/chat/ChatContainer.tsx"
      to: "components/chat/QuickReplies.tsx"
      via: "QuickReplies component import"
      pattern: "import.*QuickReplies"
    - from: "app/brief/page.tsx"
      to: "hooks/useChat.ts"
      via: "quickReplies, handleQuickReply destructuring"
      pattern: "quickReplies.*handleQuickReply"
---

<objective>
Quick-reply UI komponens + chat integration + végső vizuális és funkcionális ellenőrzés.

Purpose: Az utolsó UI réteg — a quick-reply gombok megjelennek a chatben, a felhasználó gyorsabban tud válaszolni zárt kérdésekre. A checkpoint biztosítja hogy a teljes adaptív flow működik.
Output: components/chat/QuickReplies.tsx (új), ChatContainer.tsx + ChatInput.tsx + brief/page.tsx (módosított)
</objective>

<execution_context>
@/Users/biroroland/.claude/get-shit-done/workflows/execute-plan.md
@/Users/biroroland/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-adaptive-questioning-engine/02-RESEARCH.md
@.planning/phases/02-adaptive-questioning-engine/02-CONTEXT.md
@.planning/phases/02-adaptive-questioning-engine/02-02-SUMMARY.md

# Aktuális fájlok (módosítandók)
@components/chat/ChatContainer.tsx
@components/chat/ChatInput.tsx
@app/brief/page.tsx

# Függőségek (Plan 02 kimenetei)
@hooks/useChat.ts
@types/chat.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: QuickReplies komponens + ChatContainer és ChatInput integrálás</name>
  <files>
    components/chat/QuickReplies.tsx
    components/chat/ChatContainer.tsx
    components/chat/ChatInput.tsx
    app/brief/page.tsx
  </files>
  <action>
**1. components/chat/QuickReplies.tsx — ÚJ komponens:**

```typescript
"use client";

import type { QuickReply } from "@/types/chat";

interface QuickRepliesProps {
  options: QuickReply[];
  onSelect: (value: string | null) => void;
  disabled: boolean;
}

export function QuickReplies({ options, onSelect, disabled }: QuickRepliesProps) {
  return (
    <div className="flex flex-wrap gap-2 px-4 py-3 animate-fade-in">
      {options.map((option) => (
        <button
          key={option.label}
          onClick={() => onSelect(option.value)}
          disabled={disabled}
          className="px-4 py-2 rounded-xl border border-roi-orange/30
                     text-roi-orange text-sm font-medium
                     hover:bg-roi-orange/10 hover:border-roi-orange/60
                     transition-all duration-200
                     disabled:opacity-50 disabled:cursor-not-allowed
                     active:scale-95"
        >
          {option.label}
        </button>
      ))}
    </div>
  );
}
```

Egyszerű, minimális komponens. Az `animate-fade-in` a meglévő Tailwind animáció (ellenőrizd globals.css-ben — ha nincs, adj hozzá egy alap fade-in-t).

**2. components/chat/ChatContainer.tsx — quickReplies prop + rendering:**

Új propok:
```typescript
interface ChatContainerProps {
  messages: Message[];
  onSendMessage: (message: string) => void;
  isLoading?: boolean;
  streamingContent?: string;
  quickReplies?: QuickReply[] | null;        // ÚJ
  onQuickReply?: (value: string | null) => void; // ÚJ
}
```

A quick-reply gombok renderelése a messages lista ALATT, a streaming üzenet után, a loading indicator és az input mező KÖZÖTT:

```tsx
{/* Quick-reply gombok — streaming befejezése után, input előtt */}
{quickReplies && quickReplies.length > 0 && !isLoading && !streamingContent && (
  <QuickReplies
    options={quickReplies}
    onSelect={onQuickReply || (() => {})}
    disabled={isLoading}
  />
)}
```

A pozíció: a scrollable messages area-n belül, a messagesEndRef ELŐTT. Így a gombok a legutolsó üzenet alatt jelennek meg, scrollolhatók.

Import: `import { QuickReplies } from "./QuickReplies";` és `import type { QuickReply } from "@/types/chat";`

**3. components/chat/ChatInput.tsx — placeholder frissítés tegező hangra:**

A jelenlegi magázó placeholder: `"Írja be válaszát..."` → tegezőre cserélni: `"Írd be a válaszod..."` (vagy `"Írj ide..."` — rövid és természetes)

A `placeholder` prop defaultja frissüljön:
```typescript
placeholder = "Írd be a válaszod..."
```

A "Várakozás a válaszra..." is frissüljön tegezőre: `"Gondolkodik..."` (vagy `"Kis türelmet..."`)

**4. app/brief/page.tsx — useChat hook új értékek bekötése:**

A useChat destructuring bővül:
```typescript
const {
  messages,
  isLoading,
  streamingContent,
  briefData,
  error,
  startChat,
  sendMessage,
  quickReplies,      // ÚJ
  handleQuickReply,  // ÚJ
} = useChat();
```

A ChatContainer hívás bővül:
```tsx
<ChatContainer
  messages={messages}
  isLoading={isLoading}
  streamingContent={streamingContent}
  onSendMessage={sendMessage}
  quickReplies={quickReplies}           // ÚJ
  onQuickReply={handleQuickReply}       // ÚJ
/>
```

A "Brief kész!" szekció szövege tegezőre:
- "Az AI összegyűjtötte az adatokat. Ellenőrizze és küldje el." → "Az AI összegyűjtötte az adatokat. Nézd át és küldd el."

A ChatInput placeholder a page szintjén is frissüljön ha ott van override:
- `"Várakozás a válaszra..."` → `"Gondolkodik..."`

Az error üzenetek is tegezőre:
- `"Hiba történt a chat indítása során. Kérjük, próbálja újra."` → useChat-ben frissíteni (ha Plan 02-ben nem történt meg)
- `"Hiba történt az üzenet küldése során. Kérjük, próbálja újra."` → tegezőre

Ha a useChat hook-ban vannak magázó error stringek, azokat is frissítsd:
- "Kérjük, próbálja újra." → "Kérlek, próbáld újra."
  </action>
  <verify>
`npx tsc --noEmit --pretty 2>&1 | grep -E "(QuickReplies|ChatContainer|ChatInput|brief/page)" || echo "No TS errors"`

Kézi ellenőrzés:
- QuickReplies.tsx létezik és exportálva van
- ChatContainer.tsx importálja és rendereli a QuickReplies-t
- brief/page.tsx átadja a quickReplies és handleQuickReply propokat
- Nincs magázó szöveg a chat UI-ban ("Ön", "Önök", "Írja be", "Kérjük")
  </verify>
  <done>
QuickReplies komponens kész és integrálva a ChatContainer-be. A brief/page.tsx bekötötte az új useChat értékeket. Az egész chat UI tegező.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Adaptív kérdezés teljes flow vizuális és funkcionális ellenőrzés</name>
  <files>app/brief/page.tsx</files>
  <action>
Vizuális és funkcionális checkpoint — a felhasználó ellenőrzi a teljes adaptív kérdezés flow-t a böngészőben.

A teljes Phase 2 adaptív kérdezőmotor:
- Multi-típus BriefData séma
- Tool use alapú típusfelismerés és adatgyűjtés (szerver-oldali agentic loop)
- Tegező, account manager stílusú AI
- Quick-reply gombok a chat-ben
- Adaptív kérdezési stratégia (nagy kép először, aztán részletek)
  </action>
  <verify>
1. Nyisd meg http://localhost:3000 és kattints a "Chat indítása" gombra
2. **Tegező hang ellenőrzés:** Az AI bemutatkozása tegező ("Szia!", "Neked", nem "Önnek")
3. **Típusfelismerés flow:**
   - Adj meg egy cégnevet (pl. "Kávézó Kft.")
   - Mondj egy kampánycélt: "Szeretnénk egy Google Ads kampányt a webshopunkhoz"
   - Figyeld: az AI felismeri-e a "performance_ppc" típust és természetesen megerősíti
4. **Adaptív kérdezés:**
   - Figyeld: az AI először a nagy képet kérdezi (cél, célcsoport), aztán a performance specifikus részleteket (ROAS, CPA, konverziók)
   - Adj egy rövid választ egy fontos kérdésre → az AI visszakérdez-e ("Ezt ki tudnád fejteni?")
5. **Multi-típus (ha van idő):**
   - Mondd: "Amúgy social media kampányt is tervezünk mellé"
   - Figyeld: az AI felveszi-e a social_media típust és kérdezi-e annak kérdéseit is
6. **Quick-reply gombok (ha megjelennek):**
   - Zárt kérdésnél (pl. platformok) megjelennek-e gombok
   - Kattintásra a szöveg elküldődik-e mint user üzenet
   - A gombok eltűnnek-e válasz után
7. **Összefoglaló:**
   - Válaszold meg az összes kérdést → az AI összefoglalja-e a briefet természetesen
   - Rákérdez-e: "Ez így jó? Van még valami?"

**Elfogadási kritériumok:**
- Az AI tegez végig (nincs "Ön", "Önök")
- A típusfelismerés organikusan történik (nem upfront választó)
- Az AI nem kérdez újra olyat amit már megtudott
- A chat stream folyamatos (nincs stuck/timeout)
- Ha quick-reply gombok nem jelennek meg, az is OK — a prompt dönti el
  </verify>
  <done>A felhasználó jóváhagyta a teljes adaptív kérdezés flow-t: tegező hang, típusfelismerés, adaptív kérdések, quick-reply gombok.</done>
</task>

</tasks>

<verification>
1. `npm run dev` — dev szerver hiba nélkül elindul
2. A teljes adaptív flow működik: bemutatkozás → kérdezés → típusfelismerés → típusspecifikus kérdések → összefoglaló
3. Tegező hang végig (nincs magázó maradék a UI-ban)
4. Quick-reply gombok renderelődnek ha a szerver küld ilyet
5. A briefState a kliens és szerver között szinkronban van (nem felejti el a típust/adatokat)
</verification>

<success_criteria>
A felhasználó természetes beszélgetést folytat az AI-val. Az AI felismeri a kampánytípust, megerősíti, és releváns kérdéseket tesz fel. A chat tegező, profikus, és a quick-reply gombok működnek.
</success_criteria>

<output>
After completion, create `.planning/phases/02-adaptive-questioning-engine/02-03-SUMMARY.md`
</output>
